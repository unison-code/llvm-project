#! /usr/bin/python3
#
#  Main authors:
#    Roberto Castaneda Lozano <rcas@acm.org>
#
#  This file is part of Unison, see http://unison-code.github.io
#
#  Copyright (c) 2023, Roberto Castaneda Lozano
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#  1. Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. Neither the name of the copyright holder nor the names of its contributors
#     may be used to endorse or promote products derived from this software
#     without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#

# llc-unison: script to run llc with Unison
#
# Runs llc twice to generate Unison's input, then Unison itself, and then llc
# again to emit the generated assembly code. Has the same interface as llc
# itself, plus a few additional flags to control Unison.

import os
import sys
import argparse
import subprocess
import tempfile

def execute(args, cmd):
    if args.verbose:
        print(" ".join(cmd))
    subprocess.call(cmd)
    return

def temp_filename(ext):
    return tempfile.NamedTemporaryFile(suffix=ext).name

def add_feature_argument(parser, feature, help_msg, default):
    """
    Add a Boolean, mutually-exclusive feature argument to a parser.
    """
    if default:
        default_option = '--' + feature
    else:
        default_option = '--no-' + feature
    help_string = help_msg + " (default: " + default_option + ")"
    feature_parser = parser.add_mutually_exclusive_group(required=False)
    feature_lower = feature.replace('-', '_')
    feature_parser.add_argument('--' + feature,
                                dest=feature_lower,
                                action='store_true',
                                help=help_string)
    feature_parser.add_argument('--no-' + feature,
                                dest=feature_lower,
                                action='store_false',
                                help=argparse.SUPPRESS)
    parser.set_defaults(**{feature_lower:default})

def main():
    # Intercept input file, output file, and Unison flags.
    parser = argparse.ArgumentParser(description='Run llc with Unison. The option -o must be given.')
    parser.add_argument('infile', metavar='INPUT', help='input file')
    parser.add_argument('-o', metavar='OUTPUT', help='output file')
    parser.add_argument('--uni-flags', help='flags to be passed to Unison')
    parser.add_argument('--llc', help='path to llc')
    parser.add_argument('--uni', help='path to uni')
    add_feature_argument(parser,
                         'verbose',
                         "print debug information to the standard output",
                         False)
    (args, llc_flags) = parser.parse_known_args()

    exit_pass  = "phi-node-elimination";
    entry_pass = "funclet-layout";

    # If the path to the underlying binaries is given, use it, otherwise expect
    # to find them in the PATH.
    llc = "llc" if args.llc is None else args.llc
    uni = "uni" if args.uni is None else args.uni

    # Generate main input to Unison (.ll -> .mir).

    mir = temp_filename('.mir')
    cmd_mir = [llc] + llc_flags + \
              ["-stop-before", exit_pass, "-unison-mir", "-o", mir, args.infile]
    execute(args, cmd_mir)

    # Generate initial solution for Unison (.ll -> .asm.mir).

    asm_mir = temp_filename('.asm.mir');
    cmd_asm_mir = [llc] + llc_flags + \
                  ["-stop-before", entry_pass, "-unison-mir", "-o", asm_mir, args.infile];
    execute(args, cmd_asm_mir)

    # Run Unison (.mir -> .asm.mir -> .unison.mir).

    unison_mir = temp_filename('.unison.mir');
    cmd_uni = [uni, "run", "--llvm6", "--verbose"] + \
              ["-o", unison_mir, mir, "--basefile=" + asm_mir];
    if args.uni_flags != None:
        cmd_uni += [args.uni_flags]
    execute(args, cmd_uni)

    # Generate assembly code (.unison.mir -> .s).

    cmd_s = [llc] + llc_flags + \
            ["-start-before", entry_pass, "-o", args.o, unison_mir];
    execute(args, cmd_s)

if __name__ == '__main__':
    main()
