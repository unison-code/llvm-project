# After Instruction Selection:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Expand ISel Pseudo-instructions:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Tail Duplication:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Optimize machine instruction PHIs:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Merge disjoint stack slots:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Local Stack Slot Allocation:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Remove dead machine instructions:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Machine Loop Invariant Code Motion:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	%vreg7<def> = A2_tfrsi 0; IntRegs:%vreg7
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg7; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg7
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Machine Common Subexpression Elimination:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Machine code sinking:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Peephole Optimizations:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Remove dead machine instructions:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Store Widening:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Hardware Loops:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Process Implicit Definitions:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Live Variable Analysis:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2<kill>, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3<kill>, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4<kill>, %vreg5<kill>, %vreg1<kill>; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9<kill>; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Machine Natural Loop Construction:
# Machine code for function UpdateRandomAccess: SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2<kill>, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3<kill>, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4<kill>, %vreg5<kill>, %vreg1<kill>; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9<kill>; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Eliminate PHI nodes for register allocation:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2<kill>, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3<kill>, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4<kill>, %vreg5<kill>, %vreg1<kill>; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9<kill>; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Two-Address instruction pass:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
	%vreg3<def> = L2_loadri_io %vreg2<kill>, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
	%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
	%vreg4<def> = C2_cmpeqi %vreg3<kill>, 2; PredRegs:%vreg4 IntRegs:%vreg3
	%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
	S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
	S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
	%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
	%vreg9<def> = C2_mux %vreg4<kill>, %vreg5<kill>, %vreg1<kill>; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9<kill>; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Simple Register Coalescing:
# Machine code for function UpdateRandomAccess: Post SSA

0B	BB#0: derived from LLVM BB %0
16B		%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
32B		%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
48B		%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
64B		%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
80B		%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
96B		S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
112B		S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
128B		%vreg5<def> = A2_tfrsi 1; IntRegs:%vreg5
144B		%vreg9<def> = C2_mux %vreg4, %vreg5, %vreg1; IntRegs:%vreg9,%vreg5,%vreg1 PredRegs:%vreg4
160B		S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
176B		JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Expand Condsets:
# Machine code for function UpdateRandomAccess: Post SSA

0B	BB#0: derived from LLVM BB %0
16B		%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
32B		%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
48B		%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
64B		%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
80B		%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
96B		S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
112B		S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
132B		%vreg9<def> = C2_cmoveit %vreg4, 1; IntRegs:%vreg9 PredRegs:%vreg4
140B		%vreg9<def> = A2_tfrf %vreg4<kill>, %vreg1<kill>, %vreg9<imp-use,kill>; IntRegs:%vreg9,%vreg1 PredRegs:%vreg4
160B		S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9<kill>; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
176B		JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Machine Instruction Scheduler:
# Machine code for function UpdateRandomAccess: Post SSA

0B	BB#0: derived from LLVM BB %0
16B		%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
24B		%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
32B		%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
64B		%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
132B		%vreg9<def> = C2_cmoveit %vreg4, 1; IntRegs:%vreg9 PredRegs:%vreg4
140B		%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
156B		%vreg9<def> = A2_tfrf %vreg4, %vreg1, %vreg9<imp-use>; IntRegs:%vreg9,%vreg1 PredRegs:%vreg4
164B		S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
172B		S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
188B		S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9<kill>; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
196B		JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Greedy Register Allocator:
# Machine code for function UpdateRandomAccess: Post SSA

0B	BB#0: derived from LLVM BB %0
16B		%vreg2<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img] IntRegs:%vreg2
24B		%vreg1<def> = A2_tfrsi 0; IntRegs:%vreg1
32B		%vreg3<def> = L2_loadri_io %vreg2, 24; mem:LD4[%cgep2](align=8) IntRegs:%vreg3,%vreg2
64B		%vreg4<def> = C2_cmpeqi %vreg3, 2; PredRegs:%vreg4 IntRegs:%vreg3
132B		%vreg9<def> = C2_cmoveit %vreg4, 1; IntRegs:%vreg9 PredRegs:%vreg4
140B		%vreg6<def> = A2_tfrsi 256; IntRegs:%vreg6
156B		%vreg9<def> = A2_tfrf %vreg4, %vreg1, %vreg9<imp-use>; IntRegs:%vreg9,%vreg1 PredRegs:%vreg4
164B		S4_pstorerht_abs %vreg4, <ga:@seiRandomAccess>, %vreg6; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4) PredRegs:%vreg4 IntRegs:%vreg6
172B		S4_pstorerbt_abs %vreg4, <ga:@seiRandomAccess+2>, %vreg1; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2) PredRegs:%vreg4 IntRegs:%vreg1
188B		S2_storerbabs <ga:@seiHasRandomAccess_info>, %vreg9<kill>; mem:ST1[@seiHasRandomAccess_info] IntRegs:%vreg9
196B		JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Virtual Register Rewriter:
# Machine code for function UpdateRandomAccess: Post SSA

0B	BB#0: derived from LLVM BB %0
16B		%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
24B		%R1<def> = A2_tfrsi 0
32B		%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
64B		%P0<def> = C2_cmpeqi %R0<kill>, 2
132B		%R0<def> = C2_cmoveit %P0, 1
140B		%R2<def> = A2_tfrsi 256
156B		%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
164B		S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
172B		S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
188B		S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
196B		JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Stack Slot Coloring:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Machine Loop Invariant Code Motion:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon RDF optimizations:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Shrink Wrapping analysis:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Machine Copy Propagation Pass:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Copy-To-Combine Pass:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Split Const32s and Const64s:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon NewValueJump:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Expand Predicate Spill Code:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Hardware Loop Fixup:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon generate mux instructions:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	%R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	%R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	%P0<def> = C2_cmpeqi %R0<kill>, 2
	%R0<def> = C2_cmoveit %P0, 1
	%R2<def> = A2_tfrsi 256
	%R0<def> = A2_tfrf %P0, %R1, %R0<imp-use,kill>
	S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon Packetizer:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	BUNDLE %R0<imp-def>, %R1<imp-def>
	  * %R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	  * %R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	BUNDLE %P0<imp-def>, %R0<imp-def>, %R2<imp-def>, %R0<imp-use,kill>, %R1<imp-use>
	  * %P0<def> = C2_cmpeqi %R0<kill>, 2
	  * %R0<def> = C2_cmovenewit %P0<internal>, 1
	  * %R2<def> = A2_tfrsi 256
	  * %R0<def> = A2_tfrfnew %P0<internal>, %R1, %R0<imp-use,kill,internal>
	BUNDLE %P0<imp-use,kill>, %R2<imp-use,kill>, %R1<imp-use,kill>
	  * S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	  * S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	BUNDLE %PC<imp-def,dead>, %R0<imp-use,kill>, %R31<imp-use>
	  * S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	  * JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Hexagon call frame information:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	BUNDLE %R0<imp-def>, %R1<imp-def>
	  * %R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	  * %R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	BUNDLE %P0<imp-def>, %R0<imp-def>, %R2<imp-def>, %R0<imp-use,kill>, %R1<imp-use>
	  * %P0<def> = C2_cmpeqi %R0<kill>, 2
	  * %R0<def> = C2_cmovenewit %P0<internal>, 1
	  * %R2<def> = A2_tfrsi 256
	  * %R0<def> = A2_tfrfnew %P0<internal>, %R1, %R0<imp-use,kill,internal>
	BUNDLE %P0<imp-use,kill>, %R2<imp-use,kill>, %R1<imp-use,kill>
	  * S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	  * S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	BUNDLE %PC<imp-def,dead>, %R0<imp-use,kill>, %R31<imp-use>
	  * S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	  * JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Contiguously Lay Out Funclets:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	BUNDLE %R0<imp-def>, %R1<imp-def>
	  * %R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	  * %R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	BUNDLE %P0<imp-def>, %R0<imp-def>, %R2<imp-def>, %R0<imp-use,kill>, %R1<imp-use>
	  * %P0<def> = C2_cmpeqi %R0<kill>, 2
	  * %R0<def> = C2_cmovenewit %P0<internal>, 1
	  * %R2<def> = A2_tfrsi 256
	  * %R0<def> = A2_tfrfnew %P0<internal>, %R1, %R0<imp-use,kill,internal>
	BUNDLE %P0<imp-use,kill>, %R2<imp-use,kill>, %R1<imp-use,kill>
	  * S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	  * S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	BUNDLE %PC<imp-def,dead>, %R0<imp-use,kill>, %R31<imp-use>
	  * S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	  * JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After StackMap Liveness Analysis:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	BUNDLE %R0<imp-def>, %R1<imp-def>
	  * %R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	  * %R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	BUNDLE %P0<imp-def>, %R0<imp-def>, %R2<imp-def>, %R0<imp-use,kill>, %R1<imp-use>
	  * %P0<def> = C2_cmpeqi %R0<kill>, 2
	  * %R0<def> = C2_cmovenewit %P0<internal>, 1
	  * %R2<def> = A2_tfrsi 256
	  * %R0<def> = A2_tfrfnew %P0<internal>, %R1, %R0<imp-use,kill,internal>
	BUNDLE %P0<imp-use,kill>, %R2<imp-use,kill>, %R1<imp-use,kill>
	  * S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	  * S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	BUNDLE %PC<imp-def,dead>, %R0<imp-use,kill>, %R31<imp-use>
	  * S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	  * JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

# After Live DEBUG_VALUE analysis:
# Machine code for function UpdateRandomAccess: Post SSA

BB#0: derived from LLVM BB %0
	BUNDLE %R0<imp-def>, %R1<imp-def>
	  * %R0<def> = L4_loadri_abs <ga:@img>; mem:LD4[@img]
	  * %R1<def> = A2_tfrsi 0
	%R0<def> = L2_loadri_io %R0<kill>, 24; mem:LD4[%cgep2](align=8)
	BUNDLE %P0<imp-def>, %R0<imp-def>, %R2<imp-def>, %R0<imp-use,kill>, %R1<imp-use>
	  * %P0<def> = C2_cmpeqi %R0<kill>, 2
	  * %R0<def> = C2_cmovenewit %P0<internal>, 1
	  * %R2<def> = A2_tfrsi 256
	  * %R0<def> = A2_tfrfnew %P0<internal>, %R1, %R0<imp-use,kill,internal>
	BUNDLE %P0<imp-use,kill>, %R2<imp-use,kill>, %R1<imp-use,kill>
	  * S4_pstorerht_abs %P0, <ga:@seiRandomAccess>, %R2<kill>; mem:ST2[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 0)](align=4)
	  * S4_pstorerbt_abs %P0<kill>, <ga:@seiRandomAccess+2>, %R1<kill>; mem:ST1[getelementptr inbounds (%struct.randomaccess_information_struct.1391, %struct.randomaccess_information_struct.1391* @seiRandomAccess, i32 0, i32 2)](align=2)
	BUNDLE %PC<imp-def,dead>, %R0<imp-use,kill>, %R31<imp-use>
	  * S2_storerbabs <ga:@seiHasRandomAccess_info>, %R0<kill>; mem:ST1[@seiHasRandomAccess_info]
	  * JMPret %R31, %PC<imp-def,dead>

# End machine code for function UpdateRandomAccess.

