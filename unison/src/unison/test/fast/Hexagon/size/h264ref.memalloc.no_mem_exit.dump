# After Instruction Selection:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Expand ISel Pseudo-instructions:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Tail Duplication:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Optimize machine instruction PHIs:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Merge disjoint stack slots:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Local Stack Slot Allocation:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Remove dead machine instructions:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Machine Loop Invariant Code Motion:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Machine Common Subexpression Elimination:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Machine code sinking:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Peephole Optimizations:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Remove dead machine instructions:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon Store Widening:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon Hardware Loops:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Process Implicit Definitions:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4; IntRegs:%vreg4
	%R2<def> = COPY %vreg3; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg6; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Live Variable Analysis:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0<kill>; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1<kill>, 0, %vreg0<kill>; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4<kill>; IntRegs:%vreg4
	%R2<def> = COPY %vreg3<kill>; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use,kill>, %R1<imp-use,kill>, %R2<imp-use,kill>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2<kill>; IntRegs:%vreg2
	%R1<def> = COPY %vreg6<kill>; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use,kill>, %R1<imp-use,kill>

# End machine code for function no_mem_exit.

# After Machine Natural Loop Construction:
# Machine code for function no_mem_exit: SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0<kill>; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1<kill>, 0, %vreg0<kill>; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4<kill>; IntRegs:%vreg4
	%R2<def> = COPY %vreg3<kill>; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use,kill>, %R1<imp-use,kill>, %R2<imp-use,kill>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2<kill>; IntRegs:%vreg2
	%R1<def> = COPY %vreg6<kill>; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use,kill>, %R1<imp-use,kill>

# End machine code for function no_mem_exit.

# After Eliminate PHI nodes for register allocation:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0<kill>; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1<kill>, 0, %vreg0<kill>; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4<kill>; IntRegs:%vreg4
	%R2<def> = COPY %vreg3<kill>; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use,kill>, %R1<imp-use,kill>, %R2<imp-use,kill>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2<kill>; IntRegs:%vreg2
	%R1<def> = COPY %vreg6<kill>; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use,kill>, %R1<imp-use,kill>

# End machine code for function no_mem_exit.

# After Two-Address instruction pass:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%vreg0<def> = COPY %R0<kill>; IntRegs:%vreg0
	%vreg1<def> = COPY %R29; IntRegs:%vreg1
	S2_storeri_io %vreg1<kill>, 0, %vreg0<kill>; mem:ST4[Stack] IntRegs:%vreg1,%vreg0
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	%vreg2<def> = A2_tfrsi <ga:@errortext>; IntRegs:%vreg2
	%vreg3<def> = A2_tfrsi <ga:@.str.20>; IntRegs:%vreg3
	%vreg4<def> = A2_tfrsi 300; IntRegs:%vreg4
	%R0<def> = COPY %vreg2; IntRegs:%vreg2
	%R1<def> = COPY %vreg4<kill>; IntRegs:%vreg4
	%R2<def> = COPY %vreg3<kill>; IntRegs:%vreg3
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use,kill>, %R1<imp-use,kill>, %R2<imp-use,kill>, ...
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	%vreg6<def> = A2_tfrsi 100; IntRegs:%vreg6
	%R0<def> = COPY %vreg2<kill>; IntRegs:%vreg2
	%R1<def> = COPY %vreg6<kill>; IntRegs:%vreg6
	TCRETURNi <ga:@error>, %R0<imp-use,kill>, %R1<imp-use,kill>

# End machine code for function no_mem_exit.

# After Simple Register Coalescing:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %0
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; IntRegs:%vreg0
48B		S2_storeri_io %R29, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg0
64B		ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
128B		%R0<def> = A2_tfrsi <ga:@errortext>
144B		%R1<def> = A2_tfrsi 300
160B		%R2<def> = A2_tfrsi <ga:@.str.20>
176B		J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use,kill>, %R2<imp-use,kill>, ...
192B		ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
224B		%R0<def> = A2_tfrsi <ga:@errortext>
240B		%R1<def> = A2_tfrsi 100
256B		TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use,kill>

# End machine code for function no_mem_exit.

# After Hexagon Expand Condsets:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %0
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; IntRegs:%vreg0
48B		S2_storeri_io %R29, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg0
64B		ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
128B		%R0<def> = A2_tfrsi <ga:@errortext>
144B		%R1<def> = A2_tfrsi 300
160B		%R2<def> = A2_tfrsi <ga:@.str.20>
176B		J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use,kill>, %R2<imp-use,kill>, ...
192B		ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
224B		%R0<def> = A2_tfrsi <ga:@errortext>
240B		%R1<def> = A2_tfrsi 100
256B		TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use,kill>

# End machine code for function no_mem_exit.

# After Machine Instruction Scheduler:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %0
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; IntRegs:%vreg0
24B		%R2<def> = A2_tfrsi <ga:@.str.20>
28B		%R0<def> = A2_tfrsi <ga:@errortext>
36B		%R1<def> = A2_tfrsi 300
48B		S2_storeri_io %R29, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg0
64B		ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
176B		J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
184B		%R1<def> = A2_tfrsi 100
224B		%R0<def> = A2_tfrsi <ga:@errortext>
248B		ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
256B		TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Greedy Register Allocator:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %0
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; IntRegs:%vreg0
24B		%R2<def> = A2_tfrsi <ga:@.str.20>
28B		%R0<def> = A2_tfrsi <ga:@errortext>
36B		%R1<def> = A2_tfrsi 300
48B		S2_storeri_io %R29, 0, %vreg0; mem:ST4[Stack] IntRegs:%vreg0
64B		ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
176B		J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
184B		%R1<def> = A2_tfrsi 100
224B		%R0<def> = A2_tfrsi <ga:@errortext>
248B		ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
256B		TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Virtual Register Rewriter:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

0B	BB#0: derived from LLVM BB %0
	    Live Ins: %R0
16B		%R3<def> = COPY %R0
24B		%R2<def> = A2_tfrsi <ga:@.str.20>
28B		%R0<def> = A2_tfrsi <ga:@errortext>
36B		%R1<def> = A2_tfrsi 300
48B		S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
64B		ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
176B		J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
184B		%R1<def> = A2_tfrsi 100
224B		%R0<def> = A2_tfrsi <ga:@errortext>
248B		ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
256B		TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Stack Slot Coloring:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%R3<def> = COPY %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%R1<def> = A2_tfrsi 100
	%R0<def> = A2_tfrsi <ga:@errortext>
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Machine Loop Invariant Code Motion:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%R3<def> = COPY %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%R1<def> = A2_tfrsi 100
	%R0<def> = A2_tfrsi <ga:@errortext>
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon RDF optimizations:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%R3<def> = COPY %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%R1<def> = A2_tfrsi 100
	%R0<def> = A2_tfrsi <ga:@errortext>
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Shrink Wrapping analysis:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	%R3<def> = COPY %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	ADJCALLSTACKDOWN 4, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-use>, %R30<imp-use>, %R29<imp-use>
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%R1<def> = A2_tfrsi 100
	%R0<def> = A2_tfrsi <ga:@errortext>
	ADJCALLSTACKUP 4, 0, %R29<imp-def,dead>, %R30<imp-def,dead>, %R31<imp-def,dead>, %R29<imp-use>
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = COPY %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%R1<def> = A2_tfrsi 100
	%R0<def> = A2_tfrsi <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Machine Copy Propagation Pass:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = COPY %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%R1<def> = A2_tfrsi 100
	%R0<def> = A2_tfrsi <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	TCRETURNi <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%R1<def> = A2_tfrsi 100
	%R0<def> = A2_tfrsi <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon Copy-To-Combine Pass:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%D0<def> = A4_combineii 100, <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon Split Const32s and Const64s:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%D0<def> = A4_combineii 100, <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%D0<def> = A4_combineii 100, <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon NewValueJump:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%D0<def> = A4_combineii 100, <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon Expand Predicate Spill Code:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%D0<def> = A4_combineii 100, <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon Hardware Loop Fixup:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%D0<def> = A4_combineii 100, <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon generate mux instructions:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	%R3<def> = A2_tfr %R0
	%R2<def> = A2_tfrsi <ga:@.str.20>
	%R0<def> = A2_tfrsi <ga:@errortext>
	%R1<def> = A2_tfrsi 300
	S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	%D0<def> = A4_combineii 100, <ga:@errortext>
	L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon Packetizer:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	BUNDLE %R29<imp-def>, %R30<imp-def>, %R3<imp-def>, %R2<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>, %R0<imp-use>
	  * S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	  * %R3<def> = A2_tfr %R0
	  * %R2<def> = A2_tfrsi <ga:@.str.20>
	BUNDLE %R0<imp-def>, %R1<imp-def>, %R29<imp-use>, %R3<imp-use,kill>
	  * %R0<def> = A2_tfrsi <ga:@errortext>
	  * %R1<def> = A2_tfrsi 300
	  * S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	BUNDLE %D0<imp-def>, %R0<imp-def>, %R1<imp-def>, %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	  * %D0<def> = A4_combineii 100, <ga:@errortext>
	  * L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Hexagon call frame information:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	BUNDLE %R29<imp-def>, %R30<imp-def>, %R3<imp-def>, %R2<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>, %R0<imp-use>
	  * S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	  * %R3<def> = A2_tfr %R0
	  * %R2<def> = A2_tfrsi <ga:@.str.20>
	BUNDLE %R0<imp-def>, %R1<imp-def>, %R29<imp-use>, %R3<imp-use,kill>
	  * %R0<def> = A2_tfrsi <ga:@errortext>
	  * %R1<def> = A2_tfrsi 300
	  * S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	BUNDLE %D0<imp-def>, %R0<imp-def>, %R1<imp-def>, %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	  * %D0<def> = A4_combineii 100, <ga:@errortext>
	  * L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Contiguously Lay Out Funclets:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	BUNDLE %R29<imp-def>, %R30<imp-def>, %R3<imp-def>, %R2<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>, %R0<imp-use>
	  * S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	  * %R3<def> = A2_tfr %R0
	  * %R2<def> = A2_tfrsi <ga:@.str.20>
	BUNDLE %R0<imp-def>, %R1<imp-def>, %R29<imp-use>, %R3<imp-use,kill>
	  * %R0<def> = A2_tfrsi <ga:@errortext>
	  * %R1<def> = A2_tfrsi 300
	  * S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	BUNDLE %D0<imp-def>, %R0<imp-def>, %R1<imp-def>, %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	  * %D0<def> = A4_combineii 100, <ga:@errortext>
	  * L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After StackMap Liveness Analysis:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	BUNDLE %R29<imp-def>, %R30<imp-def>, %R3<imp-def>, %R2<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>, %R0<imp-use>
	  * S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	  * %R3<def> = A2_tfr %R0
	  * %R2<def> = A2_tfrsi <ga:@.str.20>
	BUNDLE %R0<imp-def>, %R1<imp-def>, %R29<imp-use>, %R3<imp-use,kill>
	  * %R0<def> = A2_tfrsi <ga:@errortext>
	  * %R1<def> = A2_tfrsi 300
	  * S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	BUNDLE %D0<imp-def>, %R0<imp-def>, %R1<imp-def>, %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	  * %D0<def> = A4_combineii 100, <ga:@errortext>
	  * L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

# After Live DEBUG_VALUE analysis:
# Machine code for function no_mem_exit: Post SSA
Function Live Ins: %R0

BB#0: derived from LLVM BB %0
    Live Ins: %R0
	BUNDLE %R29<imp-def>, %R30<imp-def>, %R3<imp-def>, %R2<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>, %R0<imp-use>
	  * S2_allocframe 8, %R29<imp-def>, %R30<imp-def>, %R29<imp-use>, %R31<imp-use>, %R30<imp-use>; mem:ST4[<unknown>]
	  * %R3<def> = A2_tfr %R0
	  * %R2<def> = A2_tfrsi <ga:@.str.20>
	BUNDLE %R0<imp-def>, %R1<imp-def>, %R29<imp-use>, %R3<imp-use,kill>
	  * %R0<def> = A2_tfrsi <ga:@errortext>
	  * %R1<def> = A2_tfrsi 300
	  * S2_storeri_io %R29, 0, %R3<kill>; mem:ST4[Stack]
	J2_call <ga:@snprintf>, %D0<imp-def,dead>, %D1<imp-def,dead>, %R31<imp-def,dead>, %R0<imp-use>, %R1<imp-use>, %R2<imp-use>, ...
	BUNDLE %D0<imp-def>, %R0<imp-def>, %R1<imp-def>, %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	  * %D0<def> = A4_combineii 100, <ga:@errortext>
	  * L2_deallocframe %R29<imp-def>, %R30<imp-def>, %R31<imp-def>, %R30<imp-use>
	J2_jump <ga:@error>, %R0<imp-use>, %R1<imp-use>

# End machine code for function no_mem_exit.

